---
title: Do Naive xG Models underestimate Expected Goals for Top Teams?
author: Lars Maurath
date: '2020-12-20'
slug: do-naive-xg-models-underestimate-expected-goals-for-top-teams
categories: []
tags:
  - Expected Goals
  - xG
  - Central Limit Theorem
  - Simulation
image: 'img/portfolio/error_anim.gif'
showonlyimage: no
---

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@thesignigame">
<meta name="twitter:creator" content="@thesignigame">
<meta name="twitter:title" content="Do Naive xG Models underestimate Expected Goals for Top Teams?">
<meta name="twitter:description" content="A proposal for a framework to quantify relative quality of Expected Goal models by comparing cumulative xG values to goals for a sample of team seasons. Goals naturally vary around cumulative xG as their outcome is boolean while xG values are a probability between 0 & 1.">
<meta name="twitter:image" content="https://raw.githubusercontent.com/larsmaurath/significant-game/master/public/img/portfolio/error_anim.gif">

After [documenting](https://www.thesignificantgame.com/portfolio/expected-goals-model-with-tidymodels/){target="_blank"} the implementation of a simple xG model I have spent quite a bit of time thinking about what makes a good model and how you could go about quantifying its quality.

Coincidentally, a few weeks ago [Tom Worville](https://twitter.com/Worville){target="_blank"} posted the below chart which sparked a bit of a discussion around the relationship between high shooting output and overperformance of xG.

```{r echo=FALSE}
blogdown::shortcode('tweet', '1332344663605456896')
```

<br>

My intuition for this phenomenon is that high shooting output is a proxy for the quality of a team and that *naive* xG models underestimate the xG values for top teams. Given that xG models are usually by construction unbiased over all teams this also means that they should overestimate xG for poor teams (one channel how quality could impact xG over/underperformance is the finishing quality of top players that tend to be employed by top teams).

In this post I am trying to find evidence for my intuition. 

### Anecdotal evidence for Barcelona

There is no doubt that Barcelona is one of the European top clubs and thanks to Statsbomb's freely available Messi data set we have a large number of the club's shot information including xG values. As you'll probably know, Statsbomb's xG model is more sophisticated than a common location-only model as they also include goalkeeper positioning, freeze frame data and shot impact height as features in their model. 

I'll start by comparing cumulative goals, Statsbomb xG values and Naive xG values to get a sense of their behavior. I use the term *Naive model* to describe models that primarily use shot location data with simple event classifiers like body part and build-up play. My expectation is that Statsbomb's xG model is the better model and therefore tracks cumulative goals closer once a reasonable sample size has been reached.

```{r Load Libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse) # dataframe manipulation
library(dbplyr) # database access
library(DBI) # database access
library(r2d3) # evaluate D3 directly from R
library(viridis) # color scheme for pass polar
library(cowplot) # plotting the player portrait
library(broom) # getting kmeans results
library(patchwork) # combining plots
library(ggrepel) # pretty labels for scatter plot
library(r2d3) # d3 support
library(gganimate) # animation of charts
library(magick) # combining gifs
library(glue) # markdown in chart titles
library(ggtext) # markdown in chart titles
library(scales) # percent formating in charts
library(DT) # pretty tables
library(widgetframe) # pretty tables

source("https://raw.githubusercontent.com/RobWHickman/Rteta/master/R/standardize_coordinates.R")
```

```{r xG Function, echo=FALSE, message=FALSE, warning=FALSE}
compute_xg <- function(location_x, location_y, header, from_corner, from_fk, direct_fk, fast_break, penalty){
  
  distance_func <- function(x_pos, y_pos){

    x_shift <- (105 - x_pos)
    y_shift <- abs(34 - y_pos)
    
    distance <- sqrt(x_shift*x_shift + y_shift*y_shift)
  }
  
  goal_angle_func <- function(x_pos, y_pos){

    x_shift <- (105 - x_pos)
    y_shift <- abs(34 - y_pos)
    
    angle <- atan((7.32*x_shift)/(x_shift*x_shift + y_shift*y_shift - (7.32/2)*(7.32/2)))
    angle <- ifelse(angle < 0, angle + pi, angle)
    
    angle_degrees <- angle*180/pi
  }
  
  if(penalty == 1){
    return(0.75)
  }
  
  distance <- distance_func(location_x, location_y)
  angle <- goal_angle_func(location_x, location_y)
  
  xg <- 1 / (1 + exp(1.23 + 0.11*distance - 0.03*angle + 0.90*header + 0.76*from_corner + 0.29*from_fk - 0.94*direct_fk - 0.92*fast_break))
}
```

```{r Load Statsbomb data, echo=FALSE}
con <- DBI::dbConnect(RSQLite::SQLite(), dbname = "~/Desktop/statsbomb_free_data.sqlite")

shots_sb <- tbl(con, "events") %>%
  filter(type.name == "Shot") %>%
  filter(possession_team.name == "Barcelona") %>%
  select(c("type.name", "possession_team.name", "shot.statsbomb_xg", "location_x", "location_y",
           "shot.type.name", "shot.body_part.name", "play_pattern.name", "shot.outcome.name", "match_id")) %>%
  collect()

matches <- tbl(con, "matches") %>%
  select(c("match_id", "season.season_name")) %>%
  distinct() %>%
  collect()

DBI::dbDisconnect(con)

shots_sb <- shots_sb %>%
  standardize_statsbomb_x(cols = c("location_x")) %>%
  standardize_statsbomb_y(cols = c("location_y")) %>%
  rowwise() %>%
  mutate(header = if_else(shot.body_part.name == "Head", 1, 0)) %>%
  mutate(from_corner = if_else(play_pattern.name == "From Corner", 1, 0)) %>%
  mutate(from_fk = if_else(play_pattern.name == "From Free Kick", 1, 0)) %>%
  mutate(penalty = if_else(shot.type.name == "Penalty", 1, 0)) %>%
  mutate(direct_fk = 0) %>%
  mutate(fast_break = if_else(play_pattern.name == "From Counter", 1, 0)) %>%
  mutate(isGoal = ifelse(shot.outcome.name == "Goal", 1, 0)) %>%
  filter(direct_fk == 0) %>%
  filter(penalty == 0) %>%
  mutate(simple_xg = compute_xg(location_x, location_y, header, from_corner, from_fk, direct_fk, fast_break, penalty)) %>%
  ungroup()

shots_sb <- left_join(shots_sb, matches, by = "match_id") %>%
  filter(season.season_name >= "2007/2008")
```

```{r Cumulative xG, echo=FALSE}
shots_sb_plot <- shots_sb %>%
  group_by(season.season_name) %>%
  mutate(shots = row_number()) %>%
  mutate(cum_sb_xg = cumsum(shot.statsbomb_xg)) %>%
  mutate(cum_simple_xg = cumsum(simple_xg)) %>%
  mutate(`cumulative goals/xG` = cumsum(isGoal)) %>%
  ungroup()

ggplot(shots_sb_plot) +
  geom_line(aes(x = shots, y = `cumulative goals/xG`), color = "#000000") +
  geom_line(aes(x = shots, y = cum_sb_xg), color = "#DC2228") +
  geom_line(aes(x = shots, y = cum_simple_xg), color = "#91bfdb") +
  facet_wrap(~season.season_name) +
  labs(title = glue::glue("<b style = 'color:#91bfdb'>Naive</b> xG models consistently underestimate Barcelona's <b style = 'color:#000000'>cumulative goals</b>."),
       subtitle = glue::glue("<b style = 'color:#DC2228'>Statsbomb's</b> model tracks much closer.")
       ) +
  theme_minimal() +
  theme(plot.title = element_markdown(size = 12),
        plot.subtitle = element_markdown(size = 12))
```

Indeed, while also slightly lower, the Statsbomb model seems to track cumulative goals much better. xG values from the Naive model consistently underestimate goals to a much higher degree.

How does this happen? Let's assume the only differences between these two models are the additional features that Statsbomb includes. Barcelona may create chances that are above average in terms of these features (18 yard box less congested, goalkeeper in worse positioning, less marginal shots). In the Naive model each shot gets an xG value assigned that is consistent with the average situation across all teams (good or bad) for these situations. This should lead to underestimation (overestimation) of xG for top (bottom) teams.

Let's next look at the distribution of xG values produced by both models. Remember that they are based on the same sample of shots.

```{r xG Distribution, echo=FALSE}
df <- data.frame(
  x = 0.25,
  y = 1,
  label = "Both density functions describe the scaled probabilities of different xG values \nin the output of two xG models applied to the same Barcelona shots for seasons 2007/2008 - 2018/2019. \n\nMost shots have very low xG values of less than 0.10 while high xG shots are very rare even for top teams like Barcelona. \n\nBoth xG models observe shots with low and high xG with similar probability. However they deviate in the region 0.08 - 0.5. \nWhile the <b style = 'color:#91bfdb'>Naive</b> model assigns values between 0.08 and 0.20 more often, the <b style = 'color:#DC2228'>Statsbomb</b> model \nobserves values between 0.20 and 0.5 more often. \n\nThis leads to a higher average xG value from the <b style = 'color:#DC2228'>Statsbomb</b> model of 0.13 compared to 0.11 from the <b style = 'color:#91bfdb'>Naive</b> model."
)

ggplot(shots_sb) +
  geom_density(aes(simple_xg, ..scaled..), color = "#91bfdb") + 
  geom_density(aes(shot.statsbomb_xg, ..scaled..), color = "#DC2228") + 
  geom_vline(xintercept = mean(shots_sb$shot.statsbomb_xg), linetype = "dashed", color = "#DC2228") +
  geom_vline(xintercept = mean(shots_sb$simple_xg), linetype = "dashed", color = "#91bfdb") +
  geom_textbox(
    data = df,
    aes(x, y, label = label),
    width = grid::unit(4, "in"),
    height = grid::unit(2, "in"),
    hjust = 0, vjust = 1, size = 3,
  ) +
  xlab("xG values") +
  ylab("density") +
  theme_minimal()
```

What we have seen so far now is that two different xG models, on a very high level, judge a set of shots quite similarly. But there are difference that do add up over time and larger sample sizes. These differences may be significant or just random. I will next try to investigate what variation we should naturally expect between cumulative goals and xG.

### What deviation between goals and xG is abnormal?

Even if we assume that we have a perfect xG model with no estimation error (i.e. the model captures all relevant and repeatable information that influences shot outcome) there will always be residual variance: a shot with true xG of let's say 0.5 can only either result in a goal or not, i.e. a Bernoulli distributed random variable with parameter equal to xG can only take values of 1 (goal) or 0 (non-goal).

Below in the top chart, I am simulating a large number of cumulative goal paths generated from the same sequence of cumulative xG. Cumulative xG is sampled from a typical distribution like the one we have seen above for Barcelona.

```{r Load All Shots For A Given Season, echo=FALSE}
con <- DBI::dbConnect(RSQLite::SQLite(), dbname = "~/Documents/Blog/Data/data.sqlite")

matches <- tbl(con, "matches") %>%
  filter(league == "Germany") %>%
  filter(season %in% c("2017/2018", "2018/2019", "2019/2020")) %>%
  collect()

match_ids <- unique(matches$match_id)

shots <- tbl(con, "events") %>%
  filter(match_id %in% match_ids) %>%
  filter(teamId %in% c(37)) %>%
  filter(isShot == 1) %>%
  collect()

DBI::dbDisconnect(con)

shots <- shots %>%
  rowwise() %>%
  mutate(header = if_else(grepl("Head", qualifiers), 1, 0)) %>%
  mutate(from_corner = if_else(grepl("FromCorner", qualifiers), 1, 0)) %>%
  mutate(from_fk = if_else(grepl("SetPiece", qualifiers), 1, 0)) %>%
  mutate(direct_fk = if_else(grepl("DirectFreekick", qualifiers), 1, 0)) %>%
  mutate(penalty = if_else(grepl("Penalty", qualifiers), 1, 0)) %>%
  mutate(fast_break = if_else(grepl("FastBreak", qualifiers), 1, 0)) %>%
  mutate(isGoal = ifelse(isGoal == "1", 1, 0)) %>%
  filter(direct_fk == 0) %>%
  filter(penalty == 0) %>%
  standardize_opta_x(cols = c("location_x")) %>%
  standardize_opta_y(cols = c("location_y")) %>%
  mutate(xg = compute_xg(location_x, location_y, header, from_corner, from_fk, direct_fk, fast_break, penalty)) %>%
  ungroup()
```

Similar to the Barcelona chart above I show the number of shots on the x-axis and cumulative xG/goals on the y-axis. Possible cumulative goal paths are shown in grey around the red cumulative xG path. 

The second chart shows the one-sided, relative variation of the 95% confidence interval around cumulative xG.

```{r Animated simulation, echo=FALSE}
set.seed(5)

df_list <- list()

xg_sample <- as.data.frame(sample(shots$xg, 1000, replace = TRUE))
colnames(xg_sample) <- c("xg")

for(i in 1:100){

  xg_sample <- xg_sample %>%
    rowwise() %>%
    mutate(goals = rbinom(1, 1, xg)) %>%
    ungroup()

  xg_sample$cum_xg <- cumsum(xg_sample$xg)
  xg_sample$cum_goals <- cumsum(xg_sample$goals) 
    
  names(xg_sample)[names(xg_sample) == "cum_goals"] <- paste0("sim_", as.character(i))

}

xg_sample_for_plot <- xg_sample %>%
  mutate(shots = row_number()) %>%
  rowwise() %>%
  mutate(max_quant = (quantile(c_across(starts_with("sim")), probs = c(0.975)) - cum_xg) / cum_xg) %>%
  mutate(min_quant = (cum_xg - quantile(c_across(starts_with("sim")), probs = c(0.025))) / cum_xg) %>%
  mutate(min_max = max(max_quant, min_quant)) %>%
  select(-c("goals", "xg"))

xg_sample_for_plot <- xg_sample_for_plot %>%
  mutate(show_time = case_when(shots %in% c(118, 225, 450, 900) ~ 30, TRUE ~ 1)) %>%
  uncount(show_time) %>%
  mutate(reveal_time = row_number()) %>%
  pivot_longer(-c("shots", "reveal_time"), values_to = "goals") %>%
  filter(shots >= 5)

xg_sample_for_plot <- xg_sample_for_plot %>%
  mutate(
    text = case_when(
      shots < 118 ~ "With a small sample size variance dominates the actual goal tally",
      shots >= 118 & shots < 225 ~ "After 10 games actual goals vary +/- 50% around expected goals",
      shots >= 225 & shots < 450 ~ "After half a season actual goals vary +/- 33% around expected goals -\ncumulative xG of 30 can reasonably lead to 20 - 40 goals",
      shots >= 450 & shots < 900 ~ "After a full season actual goals vary +/- 20% around cumulative xG -\ncumulative xG of 50 can reasonably lead to 40 - 60 goals",
      shots >= 900               ~ "After two full seasons actual goals vary +/- 15% around expected goals -\ncumulative xG of 100 can reasonably lead to 85 - 115 goals",
      TRUE                       ~ ""
    )
  )

a <- ggplot() +
  geom_line(data = xg_sample_for_plot %>% filter(str_detect(name, "^sim")), aes(x = shots, y = goals), color = "grey", size = 0.5) +
  geom_line(data = xg_sample_for_plot %>% filter(name == "cum_xg"), aes(x = shots, y = goals), color = "tomato2") +
  scale_x_continuous(limits = c(0, NA)) +
  geom_vline(xintercept = 118, linetype = "dashed") +
  geom_vline(xintercept = 225, linetype = "dashed") +
  geom_vline(xintercept = 450, linetype = "dashed") +
  geom_vline(xintercept = 900, linetype = "dashed") +
  transition_reveal(reveal_time) +
  view_follow(fixed_x = TRUE) +
  labs(title = glue::glue("<b>Simulation of Residual Variance of a (Hypothetical) Perfect</b> <b style = 'color:tomato2'>xG Model</b>"), 
       subtitle = "Goals are modeled as Bernoulli RVs Parameterized with xG values from a 'typical' xG Distribution") +
  ylab("goals/xG") +
  theme_bw() +
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        axis.text.y = element_text(margin = margin(t = 0, r = 0, b = 0, l = 6)), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(), 
        plot.title = element_markdown(size = 9),
        plot.subtitle = element_text(size = 8)) 

b <- ggplot(xg_sample_for_plot %>% filter(name %in% c("min_max")) %>% pivot_wider(names_from = name, values_from = goals), aes(x = shots)) +
  geom_line(aes(y = min_max)) + 
  scale_x_continuous(limits = c(5, 1000)) +
  scale_y_continuous(labels = scales::percent) +
  geom_vline(xintercept = 118, linetype = "dashed") +
  annotate("text", x = 118-20, y = 0.8, colour = "black", size = 3, label = "10 Games", angle = 90, hjust = 0) +
  geom_vline(xintercept = 225, linetype = "dashed") +
  annotate("text", x = 225-20, y = 0.8, colour = "black", size = 3, label = "Half Season", angle = 90, hjust = 0) +
  geom_vline(xintercept = 450, linetype = "dashed") +
  annotate("text", x = 450-20, y = 0.8, colour = "black", size = 3, label = "Full Season", angle = 90, hjust = 0) +
  geom_vline(xintercept = 900, linetype = "dashed") +
  annotate("text", x = 900-20, y = 0.8, colour = "black", size = 3, label = "Two Seasons", angle = 90, hjust = 0) +
  transition_reveal(reveal_time) +
  view_follow(fixed_x = TRUE, fixed_y = TRUE) +
  labs(title = glue::glue("<b>Relative, one-sided error (95% confidence interval) drops with increasing sample size</b>"), 
       #subtitle = "After 10 Games actual goals may vary +/- 50% around expected goals") +
       subtitle = '{xg_sample_for_plot$text[as.integer(frame_along)*100]}') +
  xlab("shots") +
  theme_bw() +
  theme(legend.position = "none", 
        axis.title.y = element_blank(), 
        plot.title = element_markdown(size = 9),
        plot.subtitle = element_text(size = 8)) 

a_gif <- animate(a, nframes = 300, width = 600, height = 150, end_pause = 10)
b_gif <- animate(b, nframes = 300, width = 600, height = 150, end_pause = 10)

anim_save("~/Documents/a.gif", animation = a_gif)
anim_save("~/Documents/b.gif", animation = b_gif)

a_mgif <- image_read("~/Documents/a.gif")
b_mgif <- image_read("~/Documents/b.gif")

new_gif <- image_append(c(a_mgif[2], b_mgif[2]), stack = TRUE)
for(i in 3:length(a_mgif)){
  combined <- image_append(c(a_mgif[i], b_mgif[i]), stack = TRUE)
  new_gif <- c(new_gif, combined)
}

new_gif
#anim_save("~/Documents/comb.gif", animation = new_gif)
```

This simulation provides us with some useful rules of thumb for the natural variation of cumulative goals around the xG metric. Assuming a perfect model without bias and measurement error, cumulative goals will lie within a +/- 20% range around cumulative xG after one season (with 95% confidence). Variation within this range is therefore not necessarily out- or underperformance of xG, but can simply be driven by the natural variation of Bernoulli random variables.

Similar rules are +/- 50% for 10 games and +/- 33% for half a season. 

Note that seasonal data is based on an average of 450 shots which may be quite different for top or poor teams: the ranges will be tighter for teams with high shooting output and wider for low shooting teams.

Thanks to the Central Limit Theorem (CLT) we can make this analysis even more useful by deriving an analytic solution that does not rely on simulations. While the law of large numbers tells us that the sample mean will converge towards the expected value of a sequence of random variables, the CLT provides further details about the variability around the expected value given the sample size and the variance of the individual random variables (the larger the sample size and the smaller the variance, the lower the variance all else equal).

Because our sequence of shots, modeled as Bernoulli random variables, all have different mean (a shot's xG value) we cannot use the classical CLT which requires independent and identically distributed random variables. Thankfully there is a variant that relaxes the requirement of identical distribution: the Lyapunov CLT. 

<details><summary><b><p style="color:#DC2228">Click for technical details of the derivation</p></b></summary>
<p>

After checking that the Lyapunov condition holds (it generally does for Bernoulli sequences as long as the limit of the variances is not finite; some more background [here](https://math.stackexchange.com/questions/2054592/do-bernoulli-random-variables-always-satisfy-the-lyapunov-condition){target="_blank"}) we get that

<p align="center">
$\frac{1}{s_n} \sum_{i=1}^{n} (X_i - \mu_i) {\xrightarrow {d}} N(0,1)$
</p>

This means that the normalized difference of cumulative goals ($X_i$) and cumulative xG ($\mu_i$) converges in distribution to the standard normal distribution. Therefore

<p align="center">
$P(-1.96 < \frac{1}{s_n} \sum_{i=1}^{n} (X_i - \mu_i) < 1.96) \approx P(-1.96 < N(0,1) < 1.96) \approx 0.95$
</p>

and with a confidence of 95% we have that the difference between cumulative goals and xG lies between

<p align="center">
$P(-1.96s_n < \sum_{i=1}^{n} (X_i - \mu_i) < 1.96s_n)$ 
</p>

where $s_n = \sqrt{\sum_{i=1}^{n} \sigma_i^2}$, the square root of the sum of variances of the individual Bernoulli RVs.

Given that xG distributions are fairly similar across teams, I proxy $\sigma_i^2$ with a random sample of xG data which gives me a value of 

<p align="center">
$\sigma_i^2 \approx 0.0878 \approx \frac{1}{12}$
</p>

We combine this with our above result to a new rule of thumb that is a function of shot sample size *n*

<p align="center">
$P(-1.96 \sqrt{\frac{n}{12}} < \sum_{i=1}^{n} (X_i - \mu_i) < 1.96 \sqrt{\frac{n}{12}})$ 
</p>

or approximately

<p align="center">
$P(-\sqrt{\frac{n}{3}} < \sum_{i=1}^{n} (X_i - \mu_i) < \sqrt{\frac{n}{3}})$ 
</p>

</p>
</details>

<br>

For an arbitrary number of shots we now know how much deviation to expect (with 95% confidence) between cumulative xG and goals simple driven by the boolean outcome of shots. 

For example, let's say that we have xG and goals data for 100 teams based on 300 shots each. We expect that for only 5 teams, actual goals deviate from cumulative xG by more than 10 goals ($\sqrt{\frac{300}{3}} = 10$) in either direction. Again, this assumes no modeling noise (in reality every model is imperfect and will misjudge shots by some degree).

With this rule of thumb we can now investigate how actual xG models compare to this. Deviations from this rule should give us some insight into their modeling errors.

### How do actual xG Models Perform Compared to a Perfect Model?

Given that we now know a bit about how perfect xG models behave in relation to their deviation to cumulative goals over different sample sizes, we can now compare this to the behavior of the Statsbomb model and a Naive model. 

The idea is to derive some kind of estimate for how similar they behave to a hypothetical, perfect xG model. For this analysis I will proxy the Naive model again with my own implementation which only relies on location based data (+ some more event flags later).

#### Data

I am pulling xG data for the Top 5 leagues and three seasons (2017/2018, 2018/2019 and 2019/2020) from Statsbomb (via fbref.com).

This leaves us with 294 team seasons of data for number of shots, cumulative xG (for both Statsbomb and the Naive implementation) and goals. For a perfect model we expect cumulative goals to lie in a range of $\textstyle{+/- \sqrt{\dfrac{\#shots}{3}}}$ around cumulative xG for around 280 of these seasons (95% of 294). Any deviation from this may indicate the presence of modeling error in the models. 

Modeling errors would impact the cumulative xG estimate for each team season and therefore the mid-point of the range. The width of the range solely relies on the variance of a typical xG sample. As we have seen with the data for Barcelona there is not much variation in the distribution of xG values for different models.

The frequency of these *outliers* should give us an indication of the quality of the model. As we look at the performance of below models we will also include a benchmark *non-model* that simply uses the average xG (~11.5%) for every shot.

```{r Summary Statistic, echo=FALSE}
xg_df <- read_csv("../data/xg_comp.csv", col_types = cols())

xg_df <- xg_df %>%
  mutate(xg_no_model = 0.11*shots) %>%
  mutate(upper_sb = xg_statsbomb + sqrt(shots/3),
         lower_sb = xg_statsbomb - sqrt(shots/3),
         upper_location = xg_location + sqrt(shots/3),
         lower_location = xg_location - sqrt(shots/3),
         upper_header = xg_header + sqrt(shots/3),
         lower_header = xg_header - sqrt(shots/3),
         upper_buildup = xg_buildup + sqrt(shots/3),
         lower_buildup = xg_buildup - sqrt(shots/3),         
         upper_nm = xg_no_model + sqrt(shots/3),
         lower_nm = xg_no_model - sqrt(shots/3)) %>%
  mutate(in_range_sb = if_else(goals <= upper_sb & goals >= lower_sb, 1, 0),
         in_range_location = if_else(goals <= upper_location & goals >= lower_location, 1, 0),
         in_range_header = if_else(goals <= upper_header & goals >= lower_header, 1, 0),
         in_range_buildup = if_else(goals <= upper_buildup & goals >= lower_buildup, 1, 0),
         in_range_nm = if_else(goals <= upper_nm & goals >= lower_nm, 1, 0)) %>%
  mutate(xg_over_sb = goals - xg_statsbomb,
         xg_over_location = goals - xg_location,
         xg_over_header = goals - xg_header,
         xg_over_buildup = goals - xg_buildup,
         xg_over_nm = goals - xg_no_model)

table_1 <- xg_df %>% summarize(mean_sb = mean(in_range_sb), 
                               mean_buildup = mean(in_range_buildup),
                               mean_header = mean(in_range_header),
                               mean_location = mean(in_range_location),
                               mean_nm = mean(in_range_nm))

table_2 <- xg_df %>% summarize(xg_over_sb = mean(xg_over_sb),
                               xg_over_buildup = mean(xg_over_buildup),
                               xg_over_header = mean(xg_over_header),
                               xg_over_location = mean(xg_over_location),
                               xg_over_nm = mean(xg_over_nm))

sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(colspan = 5, 'Pecentage within 95% confidence interval'),
    ),
    tr(
      lapply(rep(c('Statsbomb', 'Naive (Location|Bodypart|Build-Up)', 'Naive (Location|Bodypart)', 'Naive (Location Only)', 'No Model'), 1), th)
    )
  )
))

footer <- "Top: Percentage of team seasons for which cumulative goals lie within the 95% confidence interval around cumulative xG. Lower percentages are driven by higher modeling noise that move the cumulative xG value and therefore the mid-point of the range which causes more goal paths to lie outside. Bottom: Average difference between cumulative goals and xG for all team seasons. This highlights that on average the xG measure gets things right for all models but also that the averaging masks the noise we observe for individual team seasons."

dt_1 <- datatable(table_1, container = sketch, rownames = FALSE, 
                options = list(dom = 't', columnDefs = list(list(className = 'dt-center', targets = "_all"))),
                caption = htmltools::tags$caption(style = 'caption-side: bottom; text-align: center;', 'Table 1: ', htmltools::em(footer))) %>%
  formatPercentage(c(1, 2, 3, 4, 5), 1)

widgetframe::frameWidget(dt_1)
```

```{r Summary Statistic 2, echo=FALSE}
sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(colspan = 5, 'Average Difference Between Goals and xG (By Season)')
    ),
    tr(
      lapply(rep(c('Statsbomb', 'Naive (Location|Bodypart|Build-Up)', 'Naive (Location|Bodypart)', 'Naive (Location Only)', 'No Model'), 1), th)
    )
  )
))

dt_2 <- datatable(table_2, container = sketch, rownames = FALSE, 
                options = list(dom = 't', columnDefs = list(list(className = 'dt-center', targets = "_all")))) %>%
  formatRound(c(1, 2, 3, 4, 5), digits = 1)

widgetframe::frameWidget(dt_2)
```


We observe that the Statsbomb model behaves much more similar to the perfect model and that a very simple model is closer to an even simpler *No Model*. Both the inclusion of location data and having a flag for headers (bodypart) seems to have a sizable impact on accuracy. The build-up play information is less influential. The additional Statsbomb features and their modeling capabilities then deliver again another bump in accuracy.

How should we start thinking about these possible modeling errors? Let's assume we observe a shot and assign an xG value with A Naive model. Give that we are missing a lot of information (e.g. defender positioning, possibly even bodypart or build-up play) our result will be an average of all similar situations, no matter if the goal is empty or the 6 yard box is congested. Naive models try to overcome this with additional features like flags indicating that a shot occurs after a corner or fast break, but they can hardly be perfect.

Consider the two situations below:

<iframe src="https://giphy.com/embed/A1JvXj4Guq2ndEeQjb" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/manutd-manchester-united-mufc-man-utd-A1JvXj4Guq2ndEeQjb">via GIPHY</a></p>

<iframe src="https://giphy.com/embed/jyAobhjGjm9HeJxRbE" width="480" height="440" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/mycujoo-fail-oops-you-had-one-job-jyAobhjGjm9HeJxRbE">via GIPHY</a></p>

Both shots occur from a relatively similar location in open play. A Naive xG model would assign a similar xG value to both, ignoring the fact that the first shot goes through a congested 6 yard box. A human would possibly assign an xG of 0.4 to the first situation and 0.9 to the second. 

Another great source for intuition on how additional features change xG estimates is the Statsbomb [article](https://statsbomb.com/2020/07/statsbomb-release-expected-goals-with-shot-impact-height/){target="_blank"} introducing *shot impact height*.

To make this concept a bit clearer we can look at a schematic representation:

```{r xG noise schematic, echo=FALSE}
df <- data.frame(
  x = 0.5,
  y = 4,
  label = "Distribution of likely, true xG values for <b style = 'color:#DC2228'>great</b> and <b style = 'color:#91bfdb'>poor</b> xG models"
)

mu <- 0.25
sigma_2 <- 0.005

alpha <- mu*(mu*(1-mu)/sigma_2 - 1)
beta <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)

sigma_2 <- 0.02

alpha_2 <- mu*(mu*(1-mu)/sigma_2 - 1)
beta_2 <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)

ggplot(data.frame(x = seq(0.02, 1, 0.01)), aes(x)) +
  geom_vline(xintercept = 0.25, linetype = "dashed") +
  stat_function(fun = function(x) dbeta(x, alpha, beta), color = "#DC2228", size = 0.5) +
  stat_function(fun = function(x) dbeta(x, alpha_2, beta_2), color = "#91bfdb", size = 0.5) +
  geom_textbox(
    data = df,
    aes(x, y, label = label),
    width = grid::unit(2, "in"),
    height = grid::unit(1, "in"),
    hjust = 0, vjust = 1, size = 4,
  ) +
  xlab("xG") +
  labs(title = "Schematic representation of modeling error.",
       subtitle = "Distribution of likely, true xG values around imperfect model estimate of 0.25.") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank())
```

In the above example we have modeled likely, true xG values with the help of a beta distribution with a mean of 0.25. You can think of the beta distribution as similar to the normal distribution but supported only on the interval [0, 1]. It is therefore often visibly not symmetric around the mean, particularly with means close to 0 or 1, or with high variance.

In other words, the range of possible, true xG values for a poor model is wider than for a great model. You can trust the xG estimate from the great model more.
We can also turn this thinking around: given a true xG value for a shot, poor models will generate a wider range of model estimates than great models. 

In combination with our first simulation we now have a Beta-Bernoulli model: our noisy model xG estimate is beta-distributed around the true xG value and resulting goals are then Bernoulli-distributed and parameterized with these noisy xG values.

Now comes the biggest mental leap in this post: by simulating various mean and variance parameters for the beta distribution (the proxy for model noise) and their subsequent behavior in our first simulation I will try to back out the noise within the Statsbomb and the Naive xG models.

We know that for a perfect xG model, 95% of cumulative goals lie within a certain range around cumulative xG. This drops only slightly for the Statsbomb data (~93%) but more drastic for the Naive modes (~ 79% - 86%). Which noise parameters (shift in the mean or level of variance) are consistent with such a behavior? 

```{r Simulation Table, echo=FALSE, message=FALSE, warning=FALSE}
noise_sample <- function(mu, sigma_2){
  alpha <- mu*(mu*(1-mu)/sigma_2 - 1)
  beta <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)
  
  if(sigma_2 < mu*(1-mu)){
    sample <- rbeta(1, alpha, beta)
  } else{
    sample <- mu
  }

  sample
}

biases <- c(0, 0.005, 0.01, 0.02)
variances <- c(0, 0.001, 0.005, 0.01, 0.02, 0.03)
  
cases <- crossing(biases, variances)

res_simulations <- list()

set.seed(5)

for(k in 1:10){

  ret_cases <- list()
  
  for(j in 1:nrow(cases)){
  
    bias = cases$biases[[j]]
    variance = cases$variances[[j]]
    
    df_list <- list()
    
    xg_sample <- as.data.frame(sample(shots$xg, 450, replace = TRUE))
    colnames(xg_sample) <- c("xg")
    
    sims <- list()
    
    for(i in 1:300){
      
      if(variance < 0.000000001){
        if(i <= 75){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = xg + bias)
        } else if(i >= 225){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = xg - bias)
        } else{
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = xg)
        }
        
      } else {
      
        if(i <= 75){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = noise_sample(xg + bias, variance))
        } else if(i >= 225){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = noise_sample(xg - bias, variance))
        } else{
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = noise_sample(xg, variance))
        }
      }
        
        
      xg_sample <- xg_sample %>%
        rowwise() %>%
        mutate(goals = rbinom(1, 1, xg)) %>%
        ungroup()
    
      sim_noise <- xg_sample %>%
        summarize(cum_xg = sum(xg), cum_goals = sum(goals), cum_xg_noise = sum(xg_noise)) %>%
        mutate(upper = cum_xg_noise + sqrt(450/3), lower = cum_xg_noise - sqrt(450/3)) %>%
        mutate(within = if_else((cum_goals <= upper) & (cum_goals >= lower), 1, 0))
      
      sims[[i]] <- sim_noise
    }
    
    res_case <- bind_rows(sims) %>%
      summarize(true_xg = mean(cum_xg), noise_xg = mean(cum_xg_noise), goals = mean(cum_goals), within = mean(within)) %>%
      mutate(bias = bias, variance = variance)
  
    
    ret_cases[[j]] <- res_case
  }
  
  res <- bind_rows(ret_cases) 

  
  res_simulations[[k]] <- res %>% mutate(run = k)
}

final <- bind_rows(res_simulations)

final <- final %>% group_by(bias, variance) %>% summarize(true_xg = mean(true_xg),
                                                          noise_xg = mean(noise_xg),
                                                          goals = mean(goals),
                                                          within = mean(within),
                                                          bias = mean(bias),
                                                          variance = mean(variance))

res_wide <- final %>% pivot_wider(-c("true_xg", "noise_xg", "goals"), names_from = "variance", values_from = "within")

sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 1, ''),
      th(colspan = 8, 'Variance (Based on Bias in Top/Bottom 25% of Teams)'),
    ),
    tr(
      lapply(c("Bias", variances), th)
    )
  )
))

res_wide <- res_wide %>% remove_rownames %>% column_to_rownames(var="bias")

footer <- "Most likely bias and variance parameters for sampling beta distributions for Statsbomb (red) and Naive (blue) data. Table values are the average percentage of goal paths lying within the 95% confidence interval around cumulative model xG. Goal paths are generated based on hypothetical, true xG value. The confidence interval is symmetric around the cumulative xG value of the noisy model. Noise xG values are sampled from a beta distribution with mean equal to true xG (+ potential bias) and variance as indicated in the table. Given that even naive xG models are unbiased over large samples by definition (across multiple teams, leagues and seasons), the bias is only applied to 25% of the sample, (-1)*bias to another 25% and 50% remain unbiased (10%, -10% and 80% for the bottom table)."

dt <- datatable(res_wide, 
                container = sketch, 
                rownames = TRUE, 
                options = list(dom = 't'), 
                caption = htmltools::tags$caption(style = 'caption-side: bottom; text-align: center;', 'Table 2: ', htmltools::em(footer))) %>%
  formatPercentage(c(1, 2, 3, 4, 5, 6), 1) %>%
  formatStyle(c(0), `border-right` = "solid 1px") %>%
  formatStyle(c('0.001', '0.005', '0.01', '0.02', '0.03'), border = styleInterval(c(0.92, 0.95), c('auto', '2px solid #DC2228', 'auto'))) %>%
  formatStyle(c('0.001', '0.005', '0.01', '0.02', '0.03'), border = styleInterval(c(0.78, 0.87), c('auto', '2px solid #91bfdb', 'auto')))

widgetframe::frameWidget(dt)
```

```{r Simulation Table 2, echo=FALSE, message=FALSE, warning=FALSE}
noise_sample <- function(mu, sigma_2){
  alpha <- mu*(mu*(1-mu)/sigma_2 - 1)
  beta <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)
  
  if(sigma_2 < mu*(1-mu)){
    sample <- rbeta(1, alpha, beta)
  } else{
    sample <- mu
  }

  sample
}

biases <- c(0, 0.005, 0.01, 0.02)
variances <- c(0, 0.001, 0.005, 0.01, 0.02, 0.03)
  
cases <- crossing(biases, variances)

res_simulations <- list()

set.seed(5)

for(k in 1:10){

  ret_cases <- list()
  
  for(j in 1:nrow(cases)){
  
    bias = cases$biases[[j]]
    variance = cases$variances[[j]]
    
    df_list <- list()
    
    xg_sample <- as.data.frame(sample(shots$xg, 450, replace = TRUE))
    colnames(xg_sample) <- c("xg")
    
    sims <- list()
    
    for(i in 1:300){
      
      if(variance < 0.000000001){
        if(i <= 30){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = xg + bias)
        } else if(i >= 270){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = xg - bias)
        } else{
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = xg)
        }
        
      } else {
      
        if(i <= 30){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = noise_sample(xg + bias, variance))
        } else if(i >= 270){
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = noise_sample(xg - bias, variance))
        } else{
          xg_sample <- xg_sample %>% rowwise() %>% mutate(xg_noise = noise_sample(xg, variance))
        }
      }
        
        
      xg_sample <- xg_sample %>%
        rowwise() %>%
        mutate(goals = rbinom(1, 1, xg)) %>%
        ungroup()
    
      sim_noise <- xg_sample %>%
        summarize(cum_xg = sum(xg), cum_goals = sum(goals), cum_xg_noise = sum(xg_noise)) %>%
        mutate(upper = cum_xg_noise + sqrt(450/3), lower = cum_xg_noise - sqrt(450/3)) %>%
        mutate(within = if_else((cum_goals <= upper) & (cum_goals >= lower), 1, 0))
      
      sims[[i]] <- sim_noise
    }
    
    res_case <- bind_rows(sims) %>%
      summarize(true_xg = mean(cum_xg), noise_xg = mean(cum_xg_noise), goals = mean(cum_goals), within = mean(within)) %>%
      mutate(bias = bias, variance = variance)
  
    
    ret_cases[[j]] <- res_case
  }
  
  res <- bind_rows(ret_cases) 

  
  res_simulations[[k]] <- res %>% mutate(run = k)
}

final <- bind_rows(res_simulations)

final <- final %>% group_by(bias, variance) %>% summarize(true_xg = mean(true_xg),
                                                          noise_xg = mean(noise_xg),
                                                          goals = mean(goals),
                                                          within = mean(within),
                                                          bias = mean(bias),
                                                          variance = mean(variance))

res_wide <- final %>% pivot_wider(-c("true_xg", "noise_xg", "goals"), names_from = "variance", values_from = "within")

sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 1, ''),
      th(colspan = 8, 'Variance (Based on Bias in Top/Bottom 10% of Teams)'),
    ),
    tr(
      lapply(c("Bias", variances), th)
    )
  )
))

res_wide <- res_wide %>% remove_rownames %>% column_to_rownames(var="bias")

dt <- datatable(res_wide, 
                container = sketch, 
                rownames = TRUE, 
                options = list(dom = 't')) %>%
  formatPercentage(c(1, 2, 3, 4, 5, 6), 1) %>%
  formatStyle(c(0), `border-right` = "solid 1px") %>%
  formatStyle(c('0.001', '0.005', '0.01', '0.02', '0.03'), border = styleInterval(c(0.92, 0.95), c('auto', '2px solid #DC2228', 'auto'))) %>%
  formatStyle(c('0.001', '0.005', '0.01', '0.02', '0.03'), border = styleInterval(c(0.78, 0.87), c('auto', '2px solid #91bfdb', 'auto')))

widgetframe::frameWidget(dt)
```

In the above table we see that Statsbomb's model is likely unbiased. Its behavior is most consistent with minimal bias and variance between 0.005 and 0.01. The Naive model likely contains some form of bias (~0.02) and some variance. We can see below how this would look visualized for an example xG value of 0.25. We can see that the Statsbomb model gives us larger confidence in its estimate. Potential true xG values are narrowly distributed around the estimate. 

```{r xG noise schematic 2, echo=FALSE}
df <- data.frame(
  x = 0.5,
  y = 4,
  label = "Distribution of likely, true xG values for <b style = 'color:#DC2228'>Statsbomb (bias: 0.005, variance: 0.01)</b> and <b style = 'color:#91bfdb'>Naive (bias: 0.02, variance: 0.02)</b> xG models"
)

mu <- 0.25 + 0.005
sigma_2 <- 0.01

alpha <- mu*(mu*(1-mu)/sigma_2 - 1)
beta <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)

mu <- 0.25 + 0.02
sigma_2 <- 0.02

alpha_2 <- mu*(mu*(1-mu)/sigma_2 - 1)
beta_2 <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)

ggplot(data.frame(x = seq(0.02, 1, 0.01)), aes(x)) +
  geom_vline(xintercept = 0.25, linetype = "dashed") +
  stat_function(fun = function(x) dbeta(x, alpha, beta), color = "#DC2228", size = 0.5) +
  stat_function(fun = function(x) dbeta(x, alpha_2, beta_2), color = "#91bfdb", size = 0.5) +
  geom_textbox(
    data = df,
    aes(x, y, label = label),
    width = grid::unit(2, "in"),
    height = grid::unit(1.5, "in"),
    hjust = 0, vjust = 1, size = 4,
  ) +
  xlab("xG") +
  labs(title = "Schematic representation of modeling error.",
       subtitle = "Distribution of likely, true xG values around imperfect model estimate of 0.25.") +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank())
```

A few points of caution now. The above results are based on quite a few assumptions and the above parameter estimates can only be treated as indicative. We are assuming that true xG values are beta-distributed around the xG estimate. This may vary from situation to situation but on average seems to be a good choice as it resembles the unconditional distribution of xG values.

Another modeling choice is the application of the bias in the above simulation. Given that xG models are calibrated with the goal of not showing any bias across many teams, seasons and leagues we need to be a bit clever to not introduce any overall bias. 

Similar to our initial idea of potential bias for top and bottom team, we will apply the bias only to a random 25% of sample in positive form and another 25% in negative form. Therefore we are able to introduce modeling noise without introducing overall bias to the model. The choice of 25% is arbitrary and will likely impact the overall bias estimate we find consistent with our observed data (In the second table we observe how estimated values change when only applying the bias to top/bottom 10%).

Even with the above uncertainties I think this is a very useful framework to think about relative quality of xG models.

### Do Naive xG Models underestimate Expected Goals for Top Teams?

We now have good indications that Naive xG models are biased for a certain subset of teams. We can now go back to our original question: is there systematic bias towards teams with high or low shooting volume?

To answer this, let's try to find bias in the types of teams who's seasons do not fall in the 95% confidence interval. 

Below I am plotting cumulative goals vs shots from our 294 team seasons. I am only highlighting goal data that lies outside the 95% confidence intervals for both Naive (I am using the version with most features; including body part and build-up play) and Statsbomb xG estimates. Cumulative goals that lie above the interval are highlighted blue, goals below the interval are highlighted red. 

As expected we see many more data points highlighted for the Naive data than for Statsbomb's. In both cases we see that xG gets overestimated for teams on the side of lower shot volume (red data). I assumed that xG underestimation would only happen for teams with high shot volume, but we see it happen for teams across the full range. Extreme data seems to be clustered a bit more for teams with higher shot volume, but the evidence seems pretty weak.

```{r Bias Shot SB, echo=FALSE, message=FALSE, warning=FALSE}
xg_df_sb<- xg_df %>%
  arrange(shots) %>%
  mutate(id = row_number()) %>%
  mutate(in_range_sb = as.factor(in_range_sb)) %>%
  mutate(color = if_else(goals > upper_sb, "#00A5FF", if_else(goals < lower_sb, "tomato2", "grey90")))

sb <- ggplot(xg_df_sb) +
  geom_point(aes(x = shots, y = goals, alpha = in_range_sb, color = color)) + 
  geom_point(aes(x = shots, y = xg_statsbomb, alpha = in_range_sb), color = "grey90") + 
  geom_point(aes(x = shots, y = upper_sb), color = "black", alpha = 0.05) + 
  geom_point(aes(x = shots, y = lower_sb), color = "black", alpha = 0.05) +
  stat_ellipse(aes(x = shots, y = goals, color = color), type = "norm", linetype = "dashed") +
  xlim(200, NA) +
  annotate("text", x = 250, y = 110, colour = "black", size = 3, label = "Sophisticated Model", angle = 0, hjust = 0) +
  annotate("text", x = 600, y = 15, colour = "black", size = 3, label = "shots", angle = 0, hjust = 0) +
  annotate("text", x = 200, y = 15, colour = "black", size = 3, label = "goals/xG", angle = 90, hjust = 0) +
  geom_segment(aes(x = 200, y = 60, xend = 200, yend = 115), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_segment(aes(x = 650, y = 15, xend = 730, yend = 15), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  scale_color_manual(values = c("#00A5FF" = "#00A5FF", "tomato2" = "tomato2", "grey90" = "grey90")) +
  scale_alpha_manual(values = c("1" = 0.1, "0" = 1)) +
  labs(subtitle = glue::glue("We do not see this bias for a sophisticated model. Teams <b style = 'color:#00A5FF'>overperforming</b> cumulative xG spread the whole range of shot volume")) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_markdown(size = 9),
        plot.subtitle = element_markdown(size = 8),
        axis.title = element_blank())
```

```{r Bias Shot US, echo=FALSE, message=FALSE, warning=FALSE}
xg_df_naive <- xg_df %>%
  arrange(shots) %>%
  mutate(id = row_number()) %>%
  mutate(in_range_buildup = as.factor(in_range_buildup)) %>%
  mutate(color = if_else(goals > upper_buildup, "#00A5FF", if_else(goals < lower_buildup, "tomato2", "grey90")))

naive <- ggplot(xg_df_naive) +
  geom_point(aes(x = shots, y = goals, alpha = in_range_buildup, color = color)) + 
  geom_point(aes(x = shots, y = xg_buildup, alpha = in_range_buildup), color = "grey90") + 
  geom_point(aes(x = shots, y = upper_buildup), color = "black", alpha = 0.05) + 
  geom_point(aes(x = shots, y = lower_buildup), color = "black", alpha = 0.05) +
  stat_ellipse(aes(x = shots, y = goals, color = color), type = "norm", linetype = "dashed") +
  xlim(200, NA) +
  annotate("text", x = 250, y = 110, colour = "black", size = 3, label = "Naive Model", angle = 0, hjust = 0) +
  # annotate("text", x = 600, y = 15, colour = "black", size = 3, label = "shots", angle = 0, hjust = 0) +
  # annotate("text", x = 200, y = 15, colour = "black", size = 3, label = "goals/xG", angle = 90, hjust = 0) +
  # geom_segment(aes(x = 200, y = 60, xend = 200, yend = 115), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  # geom_segment(aes(x = 650, y = 15, xend = 730, yend = 15), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  scale_color_manual(values = c("#00A5FF" = "#00A5FF", "tomato2" = "tomato2", "grey90" = "grey90")) +
  scale_alpha_manual(values = c("1" = 0.1, "0" = 1)) +
  labs(title = glue::glue("Naive xG models seem to show bias in xG estimation for teams with low and high shot volumes"),
       subtitle = glue::glue("Teams that do <b style = 'color:tomato2'>underperform</b> cumulative xG tend to have low shot volume.")) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_markdown(size = 11),
        plot.subtitle = element_markdown(size = 8),
        axis.title = element_blank())
```

```{r Bias Shot Comb, echo=FALSE, message=FALSE, warning=FALSE}
naive / sb
```

#### Sensitivity to measure of "top"

The number of taken shots over a season is a pretty vague definition of "top team". To really investigate this relationship let's look at another definition of team quality: Elo rating. Because we do not want to use a definition that relies on the coincidental performance of a team to the xG data we have, we use Elo ratings in the summer prior to a season's xG data.

```{r Bias Elo SB, echo=FALSE, message=FALSE, warning=FALSE}
xg_df_sb<- xg_df %>%
  arrange(elo) %>%
  mutate(id = row_number()) %>%
  mutate(in_range_sb = as.factor(in_range_sb)) %>%
  mutate(color = if_else(goals > upper_sb, "#00A5FF", if_else(goals < lower_sb, "tomato2", "grey90")))

sb <- ggplot(xg_df_sb) +
  geom_point(aes(x = elo, y = goals, alpha = in_range_sb, color = color)) + 
  geom_point(aes(x = elo, y = xg_statsbomb, alpha = in_range_sb), color = "grey90") + 
  geom_point(aes(x = elo, y = upper_sb), color = "black", alpha = 0.05) + 
  geom_point(aes(x = elo, y = lower_sb), color = "black", alpha = 0.05) +
  stat_ellipse(aes(x = elo, y = goals, color = color), type = "t", linetype = "dashed") +
  xlim(1200, 2200) +
  annotate("text", x = 1300, y = 110, colour = "black", size = 3, label = "Sophisticated Model", angle = 0, hjust = 0) +
  annotate("text", x = 1800, y = 15, colour = "black", size = 3, label = "Elo rating", angle = 0, hjust = 0) +
  annotate("text", x = 1200, y = 15, colour = "black", size = 3, label = "goals/xG", angle = 90, hjust = 0) +
  geom_segment(aes(x = 1200, y = 60, xend = 1200, yend = 115), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_segment(aes(x = 1900, y = 15, xend = 2000, yend = 15), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  scale_color_manual(values = c("#00A5FF" = "#00A5FF", "tomato2" = "tomato2", "grey90" = "grey90")) +
  scale_alpha_manual(values = c("1" = 0.1, "0" = 1)) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_markdown(size = 9),
        plot.subtitle = element_markdown(size = 8),
        axis.title = element_blank())
```

```{r Bias Elo US, echo=FALSE, message=FALSE, warning=FALSE}
xg_df_naive <- xg_df %>%
  arrange(elo) %>%
  mutate(id = row_number()) %>%
  mutate(in_range_buildup = as.factor(in_range_buildup)) %>%
  mutate(color = if_else(goals > upper_buildup, "#00A5FF", if_else(goals < lower_buildup, "tomato2", "grey90")))

naive <- ggplot(xg_df_naive) +
  geom_point(aes(x = elo, y = goals, alpha = in_range_buildup, color = color)) + 
  geom_point(aes(x = elo, y = xg_buildup, alpha = in_range_buildup), color = "grey90") + 
  geom_point(aes(x = elo, y = upper_buildup), color = "black", alpha = 0.05) + 
  geom_point(aes(x = elo, y = lower_buildup), color = "black", alpha = 0.05) +
  stat_ellipse(aes(x = elo, y = goals, color = color), type = "t", linetype = "dashed") +
  xlim(1200, 2200) +
  annotate("text", x = 1300, y = 110, colour = "black", size = 3, label = "Naive Model", angle = 0, hjust = 0) +
  # annotate("text", x = 600, y = 15, colour = "black", size = 3, label = "shots", angle = 0, hjust = 0) +
  # annotate("text", x = 200, y = 15, colour = "black", size = 3, label = "goals/xG", angle = 90, hjust = 0) +
  # geom_segment(aes(x = 200, y = 60, xend = 200, yend = 115), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  # geom_segment(aes(x = 650, y = 15, xend = 730, yend = 15), arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  scale_color_manual(values = c("#00A5FF" = "#00A5FF", "tomato2" = "tomato2", "grey90" = "grey90")) +
  scale_alpha_manual(values = c("1" = 0.1, "0" = 1)) +
  labs(title = glue::glue("There is little evidence for bias when conditioning on Elo rating")) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title = element_markdown(size = 11),
        plot.subtitle = element_markdown(size = 8),
        axis.title = element_blank())
```

```{r Bias Elo Comb, echo=FALSE, message=FALSE, warning=FALSE}
naive / sb
```

The analysis is pretty similar when conditioning on Elo rating instead of shot volume. In this case, shot volume may be a pretty good proxy for team quality.

Overall however, there seems to be relatively weak evidence for systematic over/underestimation of xG depending on team quality.

### Comparison to David Sumpter's (Soccermatics) Rules

A lot of the things I have looked at overlap with David Sumpter's analysis in [Should you write about real goals or expected goals?](https://soccermatics.medium.com/should-you-write-about-real-goals-or-expected-goals-a-guide-for-journalists-2cf0c7ec6bb6){target="_blank"}. My view is that my results are consistent with his findings but offer a more granular view of the variability of goals around expected goals by relating it to the number of shots not games. I also highlight the difference the quality of an xG model makes.

David answers two main questions: With what sample size does it make sense to start looking at xG values and when should you prefer actual goals over xG? 

In order to answer these questions I will initially deviate from David's guidance to again assume there is a hypothetical, perfect xG model who's output is superior even to goals at any sample size. 

Next I will measure noise to this hypothetical model for actual goals, a sophisticated model and a naive model. These two models are again proxied by the modeling errors I derived from Statsbomb and Naive data.

```{r Animation Convergence, echo=FALSE}
noise_sample <- function(mu, sigma_2){
  alpha <- mu*(mu*(1-mu)/sigma_2 - 1)
  beta <- (1-mu)*(mu*(1-mu)/sigma_2 - 1)
  
  if(sigma_2 < mu*(1-mu)){
    sample <- rbeta(1, alpha, beta)
  } else{
    sample <- mu
  }

  sample
}

set.seed(5)

df_list <- list()

xg_sample <- as.data.frame(sample(shots$xg, 2000, replace = TRUE))
colnames(xg_sample) <- c("xg")

for(i in 1:500){

  xg_sample <- xg_sample %>%
    rowwise() %>%
    mutate(goals = rbinom(1, 1, xg)) %>%
    mutate(xg_soph = noise_sample(xg + 0.005, 0.01)) %>%
    mutate(xg_naive = noise_sample(xg + 0.02, 0.02)) %>%
    ungroup()

  xg_sample$cum_xg <- cumsum(xg_sample$xg)
  xg_sample$cum_goals <- cumsum(xg_sample$goals) 
  xg_sample$cum_xg_soph <- cumsum(xg_sample$xg_soph)
  xg_sample$cum_xg_naive <- cumsum(xg_sample$xg_naive)
    
  names(xg_sample)[names(xg_sample) == "cum_goals"] <- paste0("goal_", as.character(i))
  names(xg_sample)[names(xg_sample) == "cum_xg_soph"] <- paste0("xg_soph_", as.character(i))
  names(xg_sample)[names(xg_sample) == "cum_xg_naive"] <- paste0("xg_naive_", as.character(i))
  
}

xg_sample_for_plot <- xg_sample %>%
  mutate(shots = row_number()) %>%
  rowwise() %>%
  mutate(max_goal = (quantile(c_across(starts_with("goal")), probs = c(0.975)) - cum_xg) / cum_xg) %>%
  mutate(min_goal = (cum_xg - quantile(c_across(starts_with("goal")), probs = c(0.025))) / cum_xg) %>%
  mutate(min_max_goal = max(max_goal, min_goal)) %>%
  mutate(max_xg_soph = (quantile(c_across(starts_with("xg_soph")), probs = c(0.975)) - cum_xg) / cum_xg) %>%
  mutate(min_xg_soph = (cum_xg - quantile(c_across(starts_with("xg_soph")), probs = c(0.025))) / cum_xg) %>%
  mutate(min_max_xg_soph = max(max_xg_soph, min_xg_soph)) %>%
  mutate(max_xg_naive = (quantile(c_across(starts_with("xg_naive")), probs = c(0.975)) - cum_xg) / cum_xg) %>%
  mutate(min_xg_naive = (cum_xg - quantile(c_across(starts_with("xg_naive")), probs = c(0.025))) / cum_xg) %>%
  mutate(min_max_xg_naive = max(max_xg_naive, min_xg_naive)) %>%
  select(-c("goals", "xg"))

xg_sample_for_plot <- xg_sample_for_plot %>%
  mutate(show_time = case_when(shots %in% c(118, 225, 450, 900) ~ 30, TRUE ~ 1)) %>%
  uncount(show_time) %>%
  mutate(reveal_time = row_number()) %>%
  pivot_longer(-c("shots", "reveal_time"), values_to = "goals") %>%
  filter(shots >= 5)

xg_sample_for_plot <- xg_sample_for_plot %>%
  mutate(
    text = case_when(
      shots < 59 ~ "With small sample size both xG and goals are mostly noise",
      shots >= 59 & shots < 170  ~ "After 5 games the one-sided error drops to 20% to 35% and xG values become useful",
      shots >= 170 & shots < 450 ~ "Goals pass a naive xG model in accuracy somewhere between 10 games and half a season",
      shots >= 450               ~ "The accuracy of actual goals continues to improve. Depending on the quality of the model, xG values may still be preferable",
      TRUE                       ~ ""
    )
  )

ggplot(xg_sample_for_plot %>% filter(name %in% c("min_max_goal", "min_max_xg_soph", "min_max_xg_naive")) %>% pivot_wider(names_from = name, values_from = goals), aes(x = shots)) +
  geom_line(aes(y = min_max_goal)) + 
  geom_line(aes(y = min_max_xg_soph), color = "#DC2228") + 
  geom_line(aes(y = min_max_xg_naive), color = "#91bfdb") + 
  scale_x_continuous(limits = c(5, 2000)) +
  scale_y_continuous(labels = scales::percent) +
  geom_vline(xintercept = 118, linetype = "dashed") +
  annotate("text", x = 118-20, y = 0.8, colour = "black", size = 3, label = "10 Games", angle = 90, hjust = 0) +
  geom_vline(xintercept = 225, linetype = "dashed") +
  annotate("text", x = 225-20, y = 0.8, colour = "black", size = 3, label = "Half Season", angle = 90, hjust = 0) +
  geom_vline(xintercept = 450, linetype = "dashed") +
  annotate("text", x = 450-20, y = 0.8, colour = "black", size = 3, label = "Full Season", angle = 90, hjust = 0) +
  geom_vline(xintercept = 900, linetype = "dashed") +
  annotate("text", x = 900-20, y = 0.8, colour = "black", size = 3, label = "Two Seasons", angle = 90, hjust = 0) +
  geom_vline(xintercept = 1800, linetype = "dashed") +
  annotate("text", x = 1800-20, y = 0.8, colour = "black", size = 3, label = "Four Seasons", angle = 90, hjust = 0) +
  transition_reveal(reveal_time) +
  view_follow(fixed_x = TRUE, fixed_y = TRUE) +
  labs(title = glue::glue("<b>Relative, one-sided error (95% confidence interval) for Goals, </b><b style = 'color:#DC2228'>Sophisticated</b></b><b> and </b><b style = 'color:#91bfdb'>Naive</b><b> xG</b>"), 
       subtitle = '{xg_sample_for_plot$text[as.integer(frame_along)*100*3]}') +
  xlab("shots") +
  theme_bw() +
  theme(legend.position = "none", 
        axis.title.y = element_blank(), 
        plot.title = element_markdown(size = 9),
        plot.subtitle = element_text(size = 8)) 

```

Initially, with very low sample size, we observe that both xG models have lower errors than goals. This makes intuitive sense given that goals can only take values between 0 and 1 and we need some time for the law of large numbers to kick in.

It certainly does not make sense to blindly trust xG values accrued over just one game. The one-sided width of the confidence interval for xG models lies between 33% and 60%, i.e. if your naive model provides you with cumulative xG of 1.0, true xG may very well lie anywhere between 0.4 and 1.6.

After 5 games the one-sided error drops to 20% to 35% which is definitely more useful.

Goals pass a naive xG model in accuracy somewhere between 10 games and half a season, similar to what David outlines in his analysis. Our naive xG model also seems to stop converging after this point. This is caused by its bias that systematically keeps cumulative xG values from converging to true xG for some teams.

If our modeling for the sophisticated xG model is correct, it fairs better than goals for quite some time. The error for goals only really gets comparable after two seasons. 

This really illustrates the power of a very good xG model. It allows you to act on your data earlier and provides you unique insights while other analysts have to wait until goals converge to a similar error rate.

### Summary

I have introduced a framework to roughly quantify the varying quality of xG models. By comparing their behavior in analyzing shots from almost 300 team seasons to a hypothetical, true xG model I find that the more sophisticated Statsbomb model outperforms a simpler model. 

I further investigate if any of the models show a bias in analyzing shots of teams with either high or low shot volume. I find that naive xG models tend to underestimate expected goals for teams with high shot volume and overestimate xG for teams with low shot volume. I do not find this effect for the more sophisticated Statsbomb model that includes additional features like shot freeze frames, goalkeeper positioning and shot impact height.

This effect may by driven by a systematic underestimation (overestimation) of xG for top (bottom) teams, but when conditioning on another metric of team quality (Elo ranking) I do not find this bias in either naive or sophisticated models.

A possible explanation for these observations would be that top teams with higher shot volume are more careful about choosing their shooting opportunities and when in doubt (congested 18 yard box or awkward shot height) recycle the ball instead of pulling the trigger. Another explanation could be superior finishing ability of top players. The missing evidence when conditioning on Elo ranking however call my initial intuition into question.

Along the way I also find some useful rules of thumb to help judge if goals actually significantly outperform cumulative xG or if they are within an interval consistent with the expected variation of Bernoulli random variables for a given sample size.

* For a given cumulative xG value *x* based on *n* shots, we expect the resulting goal tally to lie within the interval $[x - \sqrt{\frac{n}{3}}, x + \sqrt{\frac{n}{3}}]$. As an example: for a sample size of 300 shots this range is 20 goals wide.

* For a typical team (based on 450 shots per season of typical shot quality) goals vary 50% around cumulative xG after 10 games, 33% after half a season and 25% after a full season. These values are of course only rough guidelines.

* The above two rules seem to be consistent with David Sumpter's analysis in [Should you write about real goals or expected goals?](https://soccermatics.medium.com/should-you-write-about-real-goals-or-expected-goals-a-guide-for-journalists-2cf0c7ec6bb6){target="_blank"}

### Update

Earlier versions of this post compared Statsbomb and Understat xG data. I have since switched to comparing Statsbomb data to my own implementation of a Naive xG model. This allows me to judge more granularly the improvements achieved when adding more features (like build-up play) over location data.
